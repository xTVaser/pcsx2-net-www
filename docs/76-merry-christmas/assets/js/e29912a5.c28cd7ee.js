"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[6563],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),m=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=m(e.components);return n.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=m(a),h=r,d=u["".concat(i,".").concat(h)]||u[h]||p[h]||o;return a?n.createElement(d,s(s({ref:t},c),{},{components:a})):n.createElement(d,s({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=u;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var m=2;m<o;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},66017:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var n=a(87462),r=(a(67294),a(3905));const o={authors:["jake stine"],date:new Date("2010-08-19T00:00:00.000Z"),description:"Being an emulator of a fairly robust system (the PS2), PCSX2 typically consumes a lot of system RAM",draft:!1,tags:["devblog"],title:"Advanced Memory Management"},s=void 0,l={permalink:"/blog/2010/advanced-memory-management",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2010/advanced-memory-management/index.mdx",source:"@site/blog/2010/advanced-memory-management/index.mdx",title:"Advanced Memory Management",description:"Being an emulator of a fairly robust system (the PS2), PCSX2 typically consumes a lot of system RAM",date:"2010-08-19T00:00:00.000Z",formattedDate:"August 19, 2010",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:6.275,hasTruncateMarker:!0,authors:[{name:"Jake Stine",key:"jake stine"}],frontMatter:{authors:["jake stine"],date:"2010-08-19T00:00:00.000Z",description:"Being an emulator of a fairly robust system (the PS2), PCSX2 typically consumes a lot of system RAM",draft:!1,tags:["devblog"],title:"Advanced Memory Management"},prevItem:{title:"PS2's Programmable DMA",permalink:"/blog/2010/ps2s-programmable-dma"},nextItem:{title:"Virtualalloc On Linux",permalink:"/blog/2010/virtualalloc-on-linux"}},i={authorsImageUrls:[void 0]},m=[],c={toc:m};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Being an emulator of a fairly robust system (the PS2), PCSX2 typically\nconsumes a ",(0,r.kt)("em",{parentName:"p"},"lot")," of system RAM. It needs multitudes of caches and\nbuffers for various things. Just to give an idea, I'll list some of the\nlarger stuff and their current defaults:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"PS2 main memory ","[","32mb","]"),(0,r.kt)("li",{parentName:"ul"},"IOP memory ","[","2mb","]"),(0,r.kt)("li",{parentName:"ul"},"EE/IOP BIOS roms ","[","6mb","]"),(0,r.kt)("li",{parentName:"ul"},"Scratchpad, Hardware registers, VU memory, DMA buffers, etc ","[","4mb","]"),(0,r.kt)("li",{parentName:"ul"},"VTLB indexes, lookups, and protection tables ","[","8mb","]"),(0,r.kt)("li",{parentName:"ul"},"EE/R5900 recompiler cache ","[","16mb","]"),(0,r.kt)("li",{parentName:"ul"},"EE/R5900 recompiler block/pc translation table ","[","48mb","]"),(0,r.kt)("li",{parentName:"ul"},"R5900 memory protection mirror ","[","32mb","]"),(0,r.kt)("li",{parentName:"ul"},"IOP/R3000A recompiler cache and translation table ","[","10mb","]"),(0,r.kt)("li",{parentName:"ul"},"microVU recompiler code caches ","[","16mb ","*"," 2","]"),(0,r.kt)("li",{parentName:"ul"},"superVU recompiler code caches ","[","8mb","]")),(0,r.kt)("p",null,"If all of these things are reserved when PCSX2 starts, we have a base\nmemory footprint of over 200 megs before even a single instruction of\nPS2 code is executed! The worst part is that we could really stand to\nallocate ",(0,r.kt)("em",{parentName:"p"},"even more")," ram: some games need over 120 mb of recompiler\ncaches to run properly. Currently those games are dealt with by issuing\nperiodic recompiler resets (sluggish)."),(0,r.kt)("p",null,"Fortunately modern operating systems have a lot of built-in features\nthat help us out. Both Windows and Linux OSes use ",(0,r.kt)("em",{parentName:"p"},"virtual memory\nmapping"),' features of our Intel/AMD cpus to perform "virtual" allocations\nof large memory reserves. What this means is that initially the\nallocated memory has no actual ',(0,r.kt)("em",{parentName:"p"},"physical")," equivalent. It is only given a\nphysical presence once the memory is accessed (read or written).\nExplained as a process:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"App requests 1gb of RAM via malloc."),(0,r.kt)("li",{parentName:"ol"},'Operating system "reserves" the 1gb of RAM, which marks the virtual\naddresses for use by this memory only. In this case the memory might be\nreserved from 0x10000000 (0.4gb) -',">"," 0x50000000 (1.4gb)."),(0,r.kt)("li",{parentName:"ol"},'Operating system "commits" the 1gb of RAM, ensuring there is enough\nphysical and swapfile RAM to accommodate it. No actual memory or\nswapfile changes are made; only the tracked amount of ram/swap in\nreserve is altered.'),(0,r.kt)("li",{parentName:"ol"},"App receives a pointer to the reserved ram."),(0,r.kt)("li",{parentName:"ol"},"App reads or writes data -- 128mb worth, let's say."),(0,r.kt)("li",{parentName:"ol"},"OS receives a ",(0,r.kt)("em",{parentName:"li"},"page fault")," exception for that memory, and allocates a\nchunk of ",(0,r.kt)("em",{parentName:"li"},"physical")," RAM for it. Other processes may be swapped out to\ndisk at this time to make room for the memory in-use.")),(0,r.kt)("p",null,"Only at Point 5 does any actual physical ram get used by the program.\nPrior to Point 5, the app has used exactly 0 byte of RAM, in spite of\nallocating 1gb via ",(0,r.kt)("strong",{parentName:"p"},"malloc"),' . This feature is implicit to both Windows\nand Linux and already helps work wonders on PCSX2\'s overall memory\nfootprint. This is also why you might get "Low on virtual memory!"\nerrors even though it appears as though you have lots of free ram in the\nSystem Monitor / Process Explorer, because some apps commit lots of\nmemory but only actually access a small fraction of it.'),(0,r.kt)("p",null,"There are ways, however, to fine tune memory access and get even better\nmemory management than the implicit Windows / Linux provisions via\nmalloc. The first rule is a simple one, but one many programmers\nprobably have no idea about it:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Do not use calloc, and do not clear allocated memory by default unless you absolutely have to!")),(0,r.kt)("p",null,"Calling ",(0,r.kt)("strong",{parentName:"p"},"calloc")," instead of ",(0,r.kt)("strong",{parentName:"p"},"malloc")," causes the entire allocation\n(1gb in our above example) to be committed to physical memory because of\nits being cleared to zero. Likewise, manually clearing buffers to zero\n(or some other value) has the same effect. Even if only a small portion\nof the array ends up being used later on, its too late: the whole thing\nis sucking up resources for no good reason except to express a patterned\nfill value. Sometimes clearing buffers cannot be avoided, but most of\nthe time buffers need not be cleared at all, and programmers simply use\ncalloc or manual clears out of habit."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Using Reserve and Commit to manage recompiled code buffers.")),(0,r.kt)("p",null,"There are two phases to allocating memory on a virtual memory system, as\nnoted in the small ordered list above. By default, ",(0,r.kt)("strong",{parentName:"p"},"malloc")," will\n",(0,r.kt)("em",{parentName:"p"},"reserve")," and ",(0,r.kt)("em",{parentName:"p"},"commit")," ram together. This is done so that the system can\nensure that there is enough ram and swap to free to give the program the\nentire allocation -- ",(0,r.kt)("em",{parentName:"p"},"if")," it happens to ever need it. If the ",(0,r.kt)("em",{parentName:"p"},"commit"),"\nphase fails due to there not being enough physical ram, ",(0,r.kt)("strong",{parentName:"p"},"malloc"),"\nreturns NULL. If you manage the reserve and commit phases separately,\nthen you can reserve extra large swatches of memory addresses without\naffecting the rest of the operating system in any way; and then later on\ncommit portions of the reserve only as needed. There aren't a whole lot\nof reasons why you'd need to micro-manage the virtual memory system in\nthis way, and for most purposes simply using malloc and letting the OS\ndo its own internal management suffices nicely. Lucky for us, PCSX2 has\none!"),(0,r.kt)("p",null,"One of the troubles with recompiled code is that it can't be allowed to\n",(0,r.kt)("em",{parentName:"p"},"move")," . Typically use of ",(0,r.kt)("strong",{parentName:"p"},"malloc")," and ",(0,r.kt)("strong",{parentName:"p"},"realloc")," results in\nallocated memory moving around as it grows or shrinks. This is fine for\nmost purposes, but is disastrous to executable code since it invalidates\nall block pointers and long jumps (which use absolute addressing). In\norder to grow a recompiled code cache using traditional malloc, you have\nto clear the cache and start over -- a recompiler reset. This usually\ncauses a lengthy hiccup in emulation speed when it happens."),(0,r.kt)("p",null,"Virtual memory techniques can be used to get around that. When we\nreserve the recompiled code cache, we reserve the upper limit of what we\ndeem a sane cache size. In this case, the R5900 cache should be a\nmaximum of 48mb. The 48mb is reserved from 0x30000000-",">","0x33000000\nwhen PCSX2 starts, the first 4mb are ",(0,r.kt)("em",{parentName:"p"},"committed")," when PCSX2 starts\nexecuting R5900 code. When the cache fills, PCSX2 automatically commits\nmore memory in 128k increments, up to 48mb -- at which point the\nemulator will reset the cache and start over. Thanks to the virtual\nmemory strategy described above, only a fraction of the 48meg allocation\nactually ",(0,r.kt)("em",{parentName:"p"},"exists")," in physical ram unless more of the allocation is\nactually needed. Furthermore, computers with limited RAM resources or\ndisabled swapfiles will still be able to run PCSX2 nicely."),(0,r.kt)("p",null,"Committing blocks of memory from the 48meg reserve never alters the base\naddress of the memory, so no pointers become invalid, and no memory\nneeds to be copied or shuffled in order to make room for the larger\ncaches. The end result is near instantaneous increases in cache size,\non-the-fly! ... and all-the-while maintaining compact and efficient\nmemory footprint for games that don't need more than the basic caches."),(0,r.kt)("p",null,"On Windows this technique is implemented using\n",(0,r.kt)("a",{parentName:"p",href:"http://msdn.microsoft.com/en-us/library/aa366887.aspx"},"VirtualAlloc")," ,\nwhich is fairly well documented via the linked MSDN page. On Linux,\nhowever, things get a bit strange. The technique can be implemented\nusing a combination of\n",(0,r.kt)("a",{parentName:"p",href:"http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html"},"mmap"),"\nand\n",(0,r.kt)("a",{parentName:"p",href:"http://www.kernel.org/doc/man-pages/online/pages/man2/mprotect.2.html"},"mprotect"),"\n, but unfortunately the Linux man pages lack any actual explanation of\nhow to perform independent reserve and commit actions (but rest assured,\nit can be done). Furthermore, Linux has an implicit system enabled by\ndefault called ",(0,r.kt)("strong",{parentName:"p"},"Over-committing")," , which basically skips phase (3)\ndescribed above -- and always returns a valid pointer on calls to\nmalloc, even if the system hasn't enough ram to accommodate the\nrequest."),(0,r.kt)("p",null,"Over-committing is so surpassingly hacky and evil that it deserves a\nblog post all to itself, so stay tuned."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"To be continued..."))))}p.isMDXComponent=!0}}]);