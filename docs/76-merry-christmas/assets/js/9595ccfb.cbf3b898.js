"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[2530],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=i,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||o;return n?a.createElement(d,r(r({ref:t},p),{},{components:n})):a.createElement(d,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},24614:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const o={authors:["jake stine"],date:new Date("2010-09-14T00:00:00.000Z"),description:"Over the past two years I have become dearly intimate with Microsoft's Visual C++ 2008 compiler, and the methods it uses for optimizing code",draft:!1,tags:["devblog"],title:"MSVC 2008 Optimizer Fail"},r=void 0,s={permalink:"/blog/2010/msvc-2008-optimizer-fail",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2010/msvc-2008-optimizer-fail/index.mdx",source:"@site/blog/2010/msvc-2008-optimizer-fail/index.mdx",title:"MSVC 2008 Optimizer Fail",description:"Over the past two years I have become dearly intimate with Microsoft's Visual C++ 2008 compiler, and the methods it uses for optimizing code",date:"2010-09-14T00:00:00.000Z",formattedDate:"September 14, 2010",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:5.21,hasTruncateMarker:!0,authors:[{name:"Jake Stine",key:"jake stine"}],frontMatter:{authors:["jake stine"],date:"2010-09-14T00:00:00.000Z",description:"Over the past two years I have become dearly intimate with Microsoft's Visual C++ 2008 compiler, and the methods it uses for optimizing code",draft:!1,tags:["devblog"],title:"MSVC 2008 Optimizer Fail"},prevItem:{title:"New PCSX2 0.9.7 Beta (R3878)!",permalink:"/blog/2010/new-pcsx2-0-9-7-beta"},nextItem:{title:"PS2's Programmable DMA",permalink:"/blog/2010/ps2s-programmable-dma"}},l={authorsImageUrls:[void 0]},c=[],p={toc:c};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'Over the past two years I have become dearly intimate with Microsoft\'s\nVisual C++ 2008 compiler, and the methods it uses for optimizing code.\nNow generally speaking MSVC 2008 does well -- very well -- especially\nfor everyday "not-so-clever" code. Its global optimization feature (aka\nLinktime Code Generation, or LTCG) is also a tremendous advantage over\nGCC -- though GCC is in the process of (finally!) adding LTCG to their\nown C/C++ compiler. MSVC does have a few very annoying failings as an\noptimizer, though. ',(0,i.kt)("strong",{parentName:"p"},"The most glaring of which has to do with"),"\n",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"templated code"))," and ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"inlined functions"))," ."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Disclaimer:")," This analysis is\nfor Visual C++ 2008 only. I have not yet analyzed MSVC 2010's code\ngeneration. Some of these glitches may be improved or different (or\nworse even) in 2010. I'll post an update if/when I compile information\nit in the future."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Edit/Update: This bug only appears to manifest itself when the input\nparameters are 1st or 2nd generation propagated constants (which is hard\nto explain if you don't know what that means). So chances of hitting\nthis bug are not actually all that common, but still plausible in many\ncoding scenarios.")),(0,i.kt)("h1",{id:"inline-functions"},"Inline Functions"),(0,i.kt)("p",null,"Inline functions are the simpler sort, so I'll cover those first. Here's\na simple example of some code that will be optimized away in certain\nsituations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"static bool g_global = false;\n__forceinline void DoSomething( void* dest, size_t size )\n{\nif (dest &amp;&amp; size)  memset(dest,0,size);\n}\n\nvoid main()\n{\n[... code ...]\n\n// dest and size are known constants, so the compiler will inline the above\n// function and eliminate all its code -- ie, this line will be effectively ignored.\nDoSomething( NULL, 0 );\n\n[... code ...]\n}\n")),(0,i.kt)("p",null,"The problem is that even though the DoSomething() call is effectively\n",(0,i.kt)("em",{parentName:"p"},"ignored")," , Visual C++ will still generate code that assumes the\nfunction is modifying global memory. Why? Because the compiler's initial\nanalysis of the function doesn't take into consideration the fact that\nit is being called/inlined with constants as parameters. That means the\ncalling function ( ",(0,i.kt)("em",{parentName:"p"},"void main()")," in this case)will have to flush/reload\nany global variables that may have otherwise been able to remain in\nregisters."),(0,i.kt)("p",null,"This problem becomes worse the longer a function grows, because every\nnew piece of code int he function can introduce additional optimization\ndependencies. For example, if a function contains SSE instructions and\n128-bit stack operations, it may require mandatory stack-frame\nalignment, ",(0,i.kt)("em",{parentName:"p"},"even if the actual SSE code portions are optimized away")," ."),(0,i.kt)("h1",{id:"templates"},"Templates"),(0,i.kt)("p",null,"For those who do not know, C++ (and C99) has a feature called\ntemplating; which is at its core a type-safe and debug-friendly\nreplacement for macros. PCSX2 uses templates extensively to generate\nfunction call dispatches for various customizable features of the PS2. A\ncommon technique in templates is to use switch statements to simplify\ncode:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template&lt; uint value > void Dispatch()\n{\n[.. setup code ..]\n\nswitch(value)\n{\ncase 1: [.. do stuff ..] break;\ncase 2: [.. do stuff ..] break;\ncase 3: [.. do stuff ..] break;\n}\n\n[.. cleanup code..]\n}\n")),(0,i.kt)("p",null,"In the above example, we've created a function that executes one of four\npossible actions. The only thing that changes between each action is the\ninterior -- all actions share the same basic setup/cleanup code. Instead\nof using separate functions and/or macros to do four separate instances\nof the setup and cleanup code, we're able to merge everything into a\nsingle template function. The compiler will automatically optimize the\nfunction to use ",(0,i.kt)("em",{parentName:"p"},"only")," the selected path. If ",(0,i.kt)("em",{parentName:"p"},"'value'")," is 1, it runs\nswitch case 1. If it is 0, the entire switch is disregarded, etc."),(0,i.kt)("p",null,"The problem is the same as with the inlined function above: Visual C++'s\noptimizer bases a lot of its optimization on the ",(0,i.kt)("strong",{parentName:"p"},"whole function\nanyway")," , so dead code that isn't even part of a particular template\ncan adversely impact MSVC's code generation strategy. If only one of the\nswitch cases modifies global memory, any call to any other case will\nstill result in the compiler flushing global registers. Fortunately this\nparticular optimization is minor, and losing it has barely any\nnoticeable impact on performance on modern CPUs."),(0,i.kt)("h1",{id:"sparse-switches-and-binary-irony"},"Sparse Switches and Binary Irony"),(0,i.kt)("p",null,"A second and more serious optimization failure occurs in\ntemplated/inlined functions, however; if the function happens to use\n",(0,i.kt)("em",{parentName:"p"},"sparse")," switches. A sparse switch is one where the values are not\ncontigious. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"switch(value)\n{\ncase 0x0: if(toggle) { code; } break;\ncase 0x100: if(toggle) { code; } break;\ncase 0x101: if(toggle) { code; } break;\ncase 0x102: if(toggle) { code; } break;\ncase 0x520: if(toggle) { code; } break;\ncase 0x521: if(toggle) { code; } break;\ncase 0x522: if(toggle) { code; } break;\ncase 0x733: if(toggle) { code; } break;\n}\n")),(0,i.kt)("p",null,"In this example, MSVC's optimizer will employ the use of a ",(0,i.kt)("em",{parentName:"p"},"binary\nsearch")," to dispatch the switch. Rather than compare each value\nindividually (8 compares), it will divide the switch into halves or\nquarters. The resulting optimized code typically finds the right case in\ntwo compares, with a worst case of 3-5 compares typically (a vast\nimprovement over an individual linear search, which has a median of 4\ncompares and worst case of 8 compares). This a great and wonderful\noptimization and is often times ",(0,i.kt)("em",{parentName:"p"},"faster")," than using function lookup\ntables."),(0,i.kt)("p",null,"... but it actually ",(0,i.kt)("em",{parentName:"p"},"backfires")," if the ",(0,i.kt)("strong",{parentName:"p"},"toggle")," value is a known\nconstant (such as a template parameter). The optimization method of the\nswitch statement is made by MSVC 2008 ",(0,i.kt)("em",{parentName:"p"},"before")," it eliminates unused\ncode. So even if you explicitly assign a ",(0,i.kt)("strong",{parentName:"p"},"value")," of 0x101, MSVC 2008\nwill include its clever binary partition logic! The resulting\npseudo-code generated by the MSVC optimizer ends up looking something\nlike this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"if(value >= 0x520) return;\nif(value &lt; 0x100) return;\n\nreturn; // which is the result of case 0x101 with toggle==false;\n")),(0,i.kt)("p",null,"The explicit checks for equality are optimized out, as are all unused\ncases -- just the umbrella binary search logic remains, and all it does\nis return from the function without doing anything. So what should be a\nnull function ends up having 2 pointless compares; ironically caused by\na clever and highly effective optimization strategy in any other normal\nsituation."))}m.isMDXComponent=!0}}]);