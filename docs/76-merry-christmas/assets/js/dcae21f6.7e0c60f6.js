"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[1950],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=u(n),m=o,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,l[1]=r;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},61181:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var a=n(87462),o=(n(67294),n(3905));const i={authors:["cottonvibes"],date:new Date("2009-08-31T00:00:00.000Z"),description:"In pcsx2's advanced options dialog (if you've dared to look), you've might have noticed there's \"FPU Clamp Mode\" and \"VU Clamp Mode\" settings",draft:!1,tags:["devblog"],title:"Whats Clamping Why Do We Need It"},l=void 0,r={permalink:"/blog/2009/whats-clamping-why-do-we-need-it",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2009/whats-clamping-why-do-we-need-it/index.mdx",source:"@site/blog/2009/whats-clamping-why-do-we-need-it/index.mdx",title:"Whats Clamping Why Do We Need It",description:"In pcsx2's advanced options dialog (if you've dared to look), you've might have noticed there's \"FPU Clamp Mode\" and \"VU Clamp Mode\" settings",date:"2009-08-31T00:00:00.000Z",formattedDate:"August 31, 2009",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:5.2,hasTruncateMarker:!0,authors:[{name:"cottonvibes",key:"cottonvibes"}],frontMatter:{authors:["cottonvibes"],date:"2009-08-31T00:00:00.000Z",description:"In pcsx2's advanced options dialog (if you've dared to look), you've might have noticed there's \"FPU Clamp Mode\" and \"VU Clamp Mode\" settings",draft:!1,tags:["devblog"],title:"Whats Clamping Why Do We Need It"},prevItem:{title:"Ps2 VU Vector Unit Documentation Part 1",permalink:"/blog/2009/ps2-vu-vector-unit-documentation-part-1"},nextItem:{title:"C Exceptions Can Be An Optimization",permalink:"/blog/2009/c-exceptions-can-be-an-optimization"}},s={authorsImageUrls:[void 0]},u=[],p={toc:u};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In pcsx2's advanced options dialog (if you've dared to look), you've\nmight have noticed there's \"FPU Clamp Mode\" and \"VU Clamp Mode\"\nsettings. You may even have experimented with some of these modes and\nfound out they fix or break games.\nBut what are they doing? And why so many options?"),(0,o.kt)("p",null,"Well first you have to know what a floating point number is. A float is\nsimply a representation of a rational number from a string of bits,\nwhose decimal point can change or 'float'. (This isn't the exact\ndefinition, but good enough for this conversation)."),(0,o.kt)("p",null,'Basically there\'s something called the "The IEEE Standard for\nFloating-Point Arithmetic" (or IEEE 754), which defines floating point\nrepresentation; and most systems abide by those rules (of course not our\nwonderful PS2).'),(0,o.kt)("p",null,"There's 32-bit \"Single Precision Floats\" (commonly referred to as\n'float'), 64-bit \"Double Precision Floats\" (commonly referred to as\n'double'), and there's even 128-bit floats called Quads (most processors\ndon't support these natively)."),(0,o.kt)("p",null,"The one we're concerned about is the Single Precision Float, which is\n32bits and has a format like this"),(0,o.kt)("p",null,"S x 1bit ","|"," E x 8bits ","|"," M x 23bits"),(0,o.kt)("p",null,"S = Sign Bit (0 = Positive Number; 1 = Negative Number)\nE = Exponent (Biased according to some formula)\nM = Mantissa (Normalized with a hidden bit)\nI'm not going to go into detail on how this stuff works, but ",(0,o.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/IEEE_754-1985#Single-precision_32-bit"},"wikipedia\nis quite\nhelpful")),(0,o.kt)("p",null,'Anyways what we need to know is that the IEEE 754 standard defines\nvalues with the Exponent bits "11111111", as "NaN" values (short for\n"Not a Number").'),(0,o.kt)("p",null,"To be more precise, there's also INF (infinity) values, qNaN (quiet\nNaN), and sNaN (signaling NaN).\nBasically NaNs are given when the result of an operation is undefined."),(0,o.kt)("p",null,"Like if you divide 1 / 0, you get a NaN result, because you can't divide\na number by 0.\nOr if you take the Square-Root of a negative number, you get a NaN\nvalue."),(0,o.kt)("p",null,"INF values are basically what it sounds like, its an attempt to\nrepresent infinity."),(0,o.kt)("p",null,"The tricky part is that now that you have a NaN or INF value, if you\never try and do a calculation with them, you'll get a NaN or INF value\nas the result."),(0,o.kt)("p",null,"Example:\nNaN + 500 = NaN (generally the same NaN, since it propagates)\nINF - 19999999999 = INF"),(0,o.kt)("p",null,"This is how the IEEE 754 standard defined this stuff (I honestly don't\nlike it, but w/e)"),(0,o.kt)("p",null,"The ps2 however doesn't support NaN's and Infinities!\nSo basically, the numbers in the range of INF/NaN on a IEEE 754 pc, are\njust very-large numbers (or very small numbers if negative (if the sign\nbit is 1))."),(0,o.kt)("p",null,"For comparison of what your x86-32 CPU does VS the ps2 we have:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Your PC:"),"\n1/0 = NaN\nsqrt (-4) = NaN\nINF - 1000 = INF"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The PS2:"),"\n1/0 = Greatest Positive Float Number (0x7ffffffff)\nsqrt (-4) = sqrt(abs(-4)) = 2\nINF - 1000 = Some Large Value - 100"),(0,o.kt)("p",null,"And there's many more combinations, but the point is that the results\nare not the same between PC and the PS2."),(0,o.kt)("p",null,"So how do we solve these problems?\nWell there's no 'fast' way to emulate the ps2 behavior 100% correct\n(this would require a software FPU, which will be ",(0,o.kt)("strong",{parentName:"p"},"very-slow")," )."),(0,o.kt)("p",null,"What we do instead is use a combination of clamping, simulation, and\ncleverness."),(0,o.kt)("p",null,"The way clamping works is if a value is INF or NaN, we 'clamp' it into\nthe closest value that's not a INF or NaN.\nBasically we force values into 'normal numbers' so that it doesn't mess\nup operations as much."),(0,o.kt)("p",null,"This isn't 100% exact, but its generally 'good enough' to fix many\nproblems with games.\nLet me give you a quick example of something clamping can solve:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'int main() {\nfloat value = INF;\ndo {\nvalue = value / 2;\nif (value <= 1) {\nprint("Hello World");\nbreak;\n}\n} while (true);\n}\n')),(0,o.kt)("p",null,'If the above code was ran on the ps2, it will eventually print "Hello\nWorld", because INF is treated as a regular large number, and will\ncontinue to be divided by 2 until its less than 1.'),(0,o.kt)("p",null,'But if done on your x86-32 PC, it will never print "Hello World" but\ncontinue to loop forever, because Infinity divided by 2 is still\nInfinity!\nEver seen games that just hang in pcsx2? Sometimes its caused by\nsituations like above.'),(0,o.kt)("p",null,"Clamping can solve this problem like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'int main() {\nfloat value = INF;\ndo {\nvalue = clamp(value);  // If value is NaN/INF, make value into a big normal number value = value / 2;\nif (value <= 1) {\nprint("Hello World");\nbreak;\n}\n} while (true);\n}\n')),(0,o.kt)("p",null,"The clamping will convert the INF into a normal (ordered) number. Then\nthat normal number can be divided by 2 repetitively until its less than"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},'Then it will eventually satisfy (value less or equal 1), and print\n"Hello World".')),(0,o.kt)("p",null,"Sometimes clamping breaks games (because of a lot of reasons that will\ntake too long to explain), but the basic problem is:\nThe ps2's floats have a larger range of valid-values than your PC's\nfloats. Therefore we have to make values 'as close as possible' on the\nPC to try and make games happy."),(0,o.kt)("p",null,"Because its impossible to know if clamping will break or help a game in\nsome situations, we have different clamp modes in pcsx2's advanced\noptions.\nAlso clamping is SLOW if done a lot, so different clamp modes are faster\nthan others ('None' is the fastest of course)"),(0,o.kt)("p",null,"I also should mention that in earlier examples i said:\nsqrt(-4) = NaN; // on your PC\nsqrt(-4) = 2; // on the ps2"),(0,o.kt)("p",null,"In this case, we simulate the ps2's sqrt instruction by doing this"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"float ps2_sqrt(float value) {\nvalue = clamp(value);  // Clamp Value if NaN or Inf to an ordered/normal number\nvalue = abs(value);    // Make Positive\nvalue = sqrt(value);   // Get sqrt of now-positive value\nreturn value;\n}\n")),(0,o.kt)("p",null,"so:\nps2","_","sqrt(-4) = 2;"),(0,o.kt)("p",null,"Now this post is getting really large, and I tried to simplify things a\nlot (which may have made things more confusing).\nAnyways I hope some of this info was useful/interesting"))}d.isMDXComponent=!0}}]);