"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[2178],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||a;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6463:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var r=n(87462),o=(n(67294),n(3905));const a={authors:["jake stine"],date:new Date("2010-03-22T00:00:00.000Z"),description:"The SPU2 is the Sound Processing Unit for the Playstation 2, and works a lot like the sound card in your own PC",draft:!1,tags:["devblog"],title:"SPU2 Is More Than Just Sound"},s=void 0,i={permalink:"/blog/2010/spu2-is-more-than-just-sound",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2010/spu2-is-more-than-just-sound/index.mdx",source:"@site/blog/2010/spu2-is-more-than-just-sound/index.mdx",title:"SPU2 Is More Than Just Sound",description:"The SPU2 is the Sound Processing Unit for the Playstation 2, and works a lot like the sound card in your own PC",date:"2010-03-22T00:00:00.000Z",formattedDate:"March 22, 2010",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:3.95,hasTruncateMarker:!0,authors:[{name:"Jake Stine",key:"jake stine"}],frontMatter:{authors:["jake stine"],date:"2010-03-22T00:00:00.000Z",description:"The SPU2 is the Sound Processing Unit for the Playstation 2, and works a lot like the sound card in your own PC",draft:!1,tags:["devblog"],title:"SPU2 Is More Than Just Sound"},prevItem:{title:"PCSX2 0.9.7 Beta Released!",permalink:"/blog/2010/pcsx2-0-9-7-beta-released"},nextItem:{title:"Updated Plugins On The Beta Downloads Page",permalink:"/blog/2010/updated-plugins-on-the-beta-downloads-page"}},l={authorsImageUrls:[void 0]},u=[],c={toc:u};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The SPU2 is the ",(0,o.kt)("em",{parentName:"p"},"Sound Processing Unit")," for the Playstation 2, and works\na lot like the sound card in your own PC; albeit still quite unique in\nits approach to mixing sounds/voices and the programmable interface it\nprovides for that. But the SPU2 is more than just sound. It's one of the\nmore reliable timing mechanisms on the PS2 and games tend to use it as\nsuch. Without at least basic SPU2 emulation, no games will boot at all.\nThis isn't too surprising if you understand how console hardware\ntypically works, but what might be surprising is realizing how many\ngames won't boot even with what ",(0,o.kt)("em",{parentName:"p"},"appears")," to be fairly competent SPU2\nemulation."),(0,o.kt)("p",null,"Until SPU2-X 1.4, no SPU2 plugin had gone the distance on implementing\n",(0,o.kt)("strong",{parentName:"p"},"IRQs")," ( ",(0,o.kt)("em",{parentName:"p"},"Interrupt Requests")," ). IRQs are scheduled via specific SPU2\nmemory addresses. When a marked memory address is accessed ",(0,o.kt)("em",{parentName:"p"},"anywhere")," in\nSPU2 memory (either read or write), the IRQ is signaled to the IOP. The\nmost important IRQs on DMAs and audible voice playback have been\nsupported for eons; without these no games would boot, period!\nMeanwhile, many of the lacking IRQ checks were known, but glossed over\nbecause of overhead required for the checks (a couple other checks were\nsimply overlooked). The three main culprits for causing emulation errors\nwere as follows:"),(0,o.kt)("p",null,'1) the "free run" feature of SPU2 voices.\n2) the write-back areas for each core\'s mixed output.\n3) Reverb Processing, which uses a series of overlapping buffers to\ngenerate feedback.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Free Running Voices")),(0,o.kt)("p",null,"The SPU2 has 48 total voices (24 voices for each core), plus two\ndedicated streaming audio input sources. Each voice can play a sound\neffect or stream audio, and can either be stopped, looping, or 'free\nrunning.' Free running voices typically zero out their volume rather\nthan stopping or looping, and continue to 'play' forever (albeit\nsilently). These free running voices access inaudible areas of SPU2\nmemory and thus trigger IRQs unexpectedly -- except, of course, some\ngames are cleverly designed to expect these unexpected IRQs!"),(0,o.kt)("p",null,"Because of the overhead required to free-run otherwise silent voices,\nall other SPU2 plugins (until now!) have opted to ignore processing\nthem. This is the feature that fixes Fatal Frame 2 (Project Zero 2) and\na dozen more games."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Output Write-back Areas")),(0,o.kt)("p",null,"The SPU2 defines a handful of special areas of memory where it writes\nback sound data at various stages of the mixing process. It's perfectly\nlegal for a game to set an IRQ address within these buffers, and then\nexpect it to trigger when the SPU2 does its write-back to that address.\nThe write-back areas are mapped as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"0x0400 - 0x05FF  :  Core 0, Voice 1\n0x0600 - 0x07FF  :  Core 0, Voice 3\n0x0800 - 0x09FF  :  Core 0 Output (Left) [includes Wet/Dry/ADMA sources]\n0x0A00 - 0x0BFF  :  Core 0 Output (Right) [includes Wet/Dry/ADMA sources]\n0x0C00 - 0x0DFF  :  Core 1, Voice 1\n0x0E00 - 0x0FFF  :  Core 1, Voice 3\n\n// Following are results of mixing all 24 voices for the given Core.\n\n0x1000 - 0x11FF  :  Core 0, Dry Mix (Left)\n0x1200 - 0x13FF  :  Core 0, Dry Mix (Right)\n0x1400 - 0x15FF  :  Core 0, Wet Mix (Left)\n0x1600 - 0x17FF  :  Core 0, Wet Mix (Right)\n0x1800 - 0x19FF  :  Core 1, Dry Mix (Left)\n0x1A00 - 0x1BFF  :  Core 1, Dry Mix (Right)\n0x1C00 - 0x1DFF  :  Core 1, Wet Mix (Left)\n0x1E00 - 0x1FFF  :  Core 1, Wet Mix (Right)\n")),(0,o.kt)("p",null,"In specific, some games set an IRQA for Core0's write-back area. The IRQ\ncan either be used as a timing mechanism, or as a synchronization point\nfor post-processing audio effects. Most SPU2 plugins properly handled\nthe write-backs, but overlooked the necessity of doing IRQ checks for\nthem."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Reverb Processing")),(0,o.kt)("p",null,"The SPU2 employs a clever reverberation algorithm that utilizes multiple\noverlapping read and writeback buffers within SPU2 memory to generate\nfeedback. Each step of the reverb process accesses memory and must test\nagainst the IRQ address; for a grand total of 24 IRQ tests per Core.\nFortunately, all reverb activity occurs within a specified area of SPU2\nmemory, so for most games a single simple test can be used to exclude\nthe IRQ test."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"And It All Applies to SPU2null!")),(0,o.kt)("p",null,"This is the boring part that I'm going to look to implementing soon: In\norder for SPU2null to be fully emulation-compliant, it must properly\nsimulate ",(0,o.kt)("em",{parentName:"p"},"all")," of these things, which basically means it needs to have a\ncomplete sound mixer implemented; including reverb buffering/addressing\nlogic. It probably seems silly, but SPU2null would still be without any\nplatform dependent code or sound drivers, making it an ideal base for\nemulation analysis and as a base for future plugins."))}p.isMDXComponent=!0}}]);