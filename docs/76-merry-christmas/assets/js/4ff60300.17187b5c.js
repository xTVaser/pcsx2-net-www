"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[5796],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),u=c(a),m=o,p=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return a?n.createElement(p,s(s({ref:t},h),{},{components:a})):n.createElement(p,s({ref:t},h))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},93068:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var n=a(87462),o=(a(67294),a(3905));const r={authors:["gregory"],date:new Date("2015-02-02T00:00:00.000Z"),description:"After a long delay, this is the second part of the MMU mini-presentation",draft:!1,tags:["devblog"],title:"Mmu Mini Series Part2 4"},s=void 0,i={permalink:"/blog/2015/mmu-mini-series-part2-4",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2015/mmu-mini-series-part2-4/index.mdx",source:"@site/blog/2015/mmu-mini-series-part2-4/index.mdx",title:"Mmu Mini Series Part2 4",description:"After a long delay, this is the second part of the MMU mini-presentation",date:"2015-02-02T00:00:00.000Z",formattedDate:"February 2, 2015",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:6.205,hasTruncateMarker:!0,authors:[{name:"Gregory",url:"https://github.com/gregory38",imageURL:"https://github.com/gregory38.png",key:"gregory"}],frontMatter:{authors:["gregory"],date:"2015-02-02T00:00:00.000Z",description:"After a long delay, this is the second part of the MMU mini-presentation",draft:!1,tags:["devblog"],title:"Mmu Mini Series Part2 4"},prevItem:{title:"Linux News",permalink:"/blog/2015/linux-news"},nextItem:{title:"Merry Christmas From The PCSX2 Team",permalink:"/blog/2014/merry-christmas-from-the-pcsx2-team"}},l={authorsImageUrls:[void 0]},c=[],h={toc:c};function d(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Hello PCSX2 followers,"),(0,o.kt)("p",null,"After a long delay, this is the second part of the MMU\nmini-presentation. In the previous chapter we saw that MMU allows giving\na virtual address space to a process. Besides, I told you MMU controls\nthe cache behavior (cacheable/uncached accelerated/uncached). First, let\nme quickly explain the different cache accesses. Then I will introduce\nthe default memory mapping of the PS2."),(0,o.kt)("p",null,"So let's start with a short explanation of the cache. The goal of\ncaching is to hide RAM latency. RAM is a very slow memory. It's not as\nslow as an HDD/SSD but still very slow. Any access requires a full\nprotocol to prepare the data. You need to select the line, the column,\ncharge output buffer... A RAM access costs you a hundred of CPU cycles.\nIn the meantime, the CPU is idling if it misses instruction or data. It\nis very annoying, only 10% of the CPU would be used. The biggest cost is\nthe setup of the RAM, transfer speed remains reasonable. So a 64 bytes\ntransfer is a bit slower than a 4 bytes transfer. But a 64 bytes\ntransfer is way faster than two 4 bytes transfers. Therefore, it is more\nefficient to load/store data by 64 bytes packets. Note: generally cache\nlines are 64 bytes wide."),(0,o.kt)("p",null,"Employing a cache is a clever solution to avoid multiple CPU-RAM\ntransfers. It is based on two properties: spacial locality\n(instructions/data are closely packed) and temporal locality (program\nloop/reuse of the same data again and again over the time). The general\nidea of caching is to create a small, but fast memory. 1% of your RAM\ndata is used 99% of the time (a.k.a. the general 90/10 rules). So if you\njust put those 1% inside the cache, 99% of your accesses will be fast"),(0,o.kt)("p",null,"Well let's say not too slow, even the fastest cache still has 2 or 3 CPU\ncycles access time."),(0,o.kt)("p",null,"Cache is really nice but there are a couple of scenarios where you\nmustn't use it: Coherency and performance. Wait, we just said that cache\naccelerate memory access and so improves performance? That is true, but\nonly if the data has temporal locality. If you want to access the data\nonly once, it won't be efficient. You pay an extra latency cost (the\ncache layer) for no gain because data won't be reused. It is even worse!\nUseful data will be evicted from the cache. We really want to keep the\n1% of frequently used data on the cache. Don't worry, we aren't doomed,\nthere is still a way to accelerate this kind of transfer. The PS2 has a\nspecial mode called \"uncached accelerated\" that will be discussed a bit\nlater."),(0,o.kt)("p",null,"Now let's talk about coherency. Coherency is very critical to ensure\nsystem stability. The cache is a copy of RAM. If the hardware (typically\nthe DMAC) updates the memory content, the data of the cache will be\nwrong and your CPU will be screwed. This kind of memory is called\nvolatile, it means hardware can update it without any notice to the CPU.\nCache will be disabled to ease the management of this special memory. No\ncache means no copy, means no coherency issue."),(0,o.kt)("p",null,'You now understand the reason to disable the cache. Let\'s continue with\nthe explanation of the "uncached accelerated" mode. I told you that a 64\nbytes transfer is much faster than several small transfers. There must\nbe a way to exploit this feature. CPU registers are only 16 bytes wide,\nway too short. So the engineers added a couple of extra buffers (64\nbytes wide). Those buffers allow you to transfer 64 bytes at once from\nthe RAM without any pollution of the cache. You directly do a\ncomputation on the data and send it back to the RAM, therefore you can\nfully exploit your RAM. Note, on your PC this feature is often called\nwrite-combining.'),(0,o.kt)("p",null,"Let's conclude this cache chapter. In short there are 3 cache modes"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"uncached for volatile access"),(0,o.kt)("li",{parentName:"ol"},"uncached accelerated for data that will be used once"),(0,o.kt)("li",{parentName:"ol"},"cache to accelerate all remaining situations")),(0,o.kt)("p",null,"On the PS2, 95% of the MMU job is to select the cache. The remaining 5%\nis to forbid the game to use/access special resources (OS\ncounter/SIF/kernel code). Very few games (I know only one) use the MMU\nto remap a page during the game. Nearly all games use a default mapping\nthat allows accessing all hardware resources."),(0,o.kt)("p",null,"PS2 MMU specification:\nEntries: 48 double pages (pages are mapped by block of two, the odd and\neven pages, so in total you can map 96 pages)\nPage size: 4K/16K/64K/256K/1M/4M/16M"),(0,o.kt)("p",null,"Default mapping: 39 entries already allocated and reserved for the OS.\nOnly 9 entries remain for the games but we don't care. As I said, all\nthe memory is already mapped, so we don't need more. Besides, it removes\nthe handling of TLB miss that is very expensive. It is clearly much more\nefficient than a standard PC."),(0,o.kt)("p",null,"Here is an overview of the TLB configuration."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(36362).Z,width:"680",height:"318"})),(0,o.kt)("p",null,"As you can see, there are 2 modes, a USER mode for the game and a KERNEL\nmode for the PS2 OS. The mode selection is done by a CPU configuration\nregister. Syscalls are generally used to switch to higher privilege\nmodes, but that's another story, albeit very interesting"),(0,o.kt)("p",null,"Please note that TLB is only used for USER mode. The kernel is god, it\ncan access anything therefore it uses physical addresses directly. On\nthe contrary the game is limited to the mapped memory, it means that\ngames can only access 31.5MB. Besides, some registers are read only (EE\ncounter 2/3 and SIF DMA), in others words they are reserved for the\nkernel."),(0,o.kt)("p",null,"It's about time that we answer the mini quiz of the previous series:\n","*"," The first 512KB of RAM is not virtually mapped because it is at the\nlocation of the OS, do you know how the kernel will access this\nlocation?\nThe kernel is like god it can use physical addresses directly. The\naddress will range from 0x8000","_","0000 to 0x9FFF","_","FFFF. Those accesses are\ncache accelerated."),(0,o.kt)("p",null,"*"," A hardware component needs to access the memory without the CPU\nintervention. Do you know which one? Do you know how the addresses are\nhandled?"),(0,o.kt)("p",null,"The component is the Direct Memory Access Controller (aka DMAC). This\ncomponent is allowed to do a Direct Memory Access (DMA) behind the CPU,\nin others words it can copy data around the chip. This way the CPU can\nwork without any interruption. However, memory is volatile from the CPU\npoint of view so access to this memory must be done uncached. In\nparticular the kernel will use this address range\n0xA000","_","0000-0xBFFF","_","FFFF"),(0,o.kt)("p",null,"To conclude this post, the memory subsystem is very critical for\nperformance and the MMU is a very powerful mechanism to control memory\naccess. However, the MMU is completely underused on the PS2. Let's be\nhonest it is a waste of die space. A hardwired implementation (as done\nby older consoles) would have been 10 times more efficient. So why did\nSony keep the MMU? I don't know! Here are some possibilities:"),(0,o.kt)("p",null,"*"," to support Linux\n","*"," no right to modify this part of the CPU (remember it is based on\nMIPS)\n","*"," to reduce cost and time to market"),(0,o.kt)("p",null,"That's all for today. Next time you'll see how I managed to make Goemon\n(\n",(0,o.kt)("a",{parentName:"p",href:"http://forums.pcsx2.net/Thread-Bouken-Jidai-Katsugeki-Goemon-SLPM-65014-J"},"http://forums.pcsx2.net/Thread-Bouken-Jidai-Katsugeki-Goemon-SLPM-65014-J"),"\n) playable with this knowledge."))}d.isMDXComponent=!0},36362:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/mmu_memory_map_s-7bccec359b7cadb589eb06f031cc97ac.webp"}}]);