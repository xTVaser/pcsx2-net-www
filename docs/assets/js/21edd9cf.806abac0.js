"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[2313],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||a;return n?o.createElement(h,i(i({ref:t},u),{},{components:n})):o.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},13816:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(87462),r=(n(67294),n(3905));const a={authors:["gregory"],date:new Date("2017-02-14T00:00:00.000Z"),description:"Quality & assurance is a full time job and it is a complex topic",draft:!1,tags:["devblog"],title:"QA Picking Our Noes"},i=void 0,s={permalink:"/pcsx2-net-www/blog/2017/qa-picking-our-noes",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2017/qa-picking-our-noes/index.mdx",source:"@site/blog/2017/qa-picking-our-noes/index.mdx",title:"QA Picking Our Noes",description:"Quality & assurance is a full time job and it is a complex topic",date:"2017-02-14T00:00:00.000Z",formattedDate:"February 14, 2017",tags:[{label:"devblog",permalink:"/pcsx2-net-www/blog/tags/devblog"}],readingTime:8.34,hasTruncateMarker:!0,authors:[{name:"Gregory",url:"https://github.com/gregory38",imageURL:"https://github.com/gregory38.png",key:"gregory"}],frontMatter:{authors:["gregory"],date:"2017-02-14T00:00:00.000Z",description:"Quality & assurance is a full time job and it is a complex topic",draft:!1,tags:["devblog"],title:"QA Picking Our Noes"},prevItem:{title:"Q1 2017 Progress Report",permalink:"/pcsx2-net-www/blog/2017/q1-2017-progress-report"},nextItem:{title:"Q4 2016 Progress Report",permalink:"/pcsx2-net-www/blog/2017/q4-2016-progress-report"}},l={authorsImageUrls:[void 0]},c=[{value:"Compiler",id:"compiler",level:2},{value:"Formal/Lint Tool",id:"formallint-tool",level:2},{value:"Cppcheck",id:"cppcheck",level:2},{value:"Coverity",id:"coverity",level:2},{value:"Clang-tidy",id:"clang-tidy",level:2},{value:"Valgrind",id:"valgrind",level:2},{value:"Address sanitizer",id:"address-sanitizer",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"quality-assurance"},"Quality Assurance"),(0,r.kt)("p",null,"Quality & assurance is a full time\njob and it is a complex topic. Quality always comes with a trade-off of\ntime vs cost. By definition, open source projects make a false start\nhere. Spending $100,000 on a formal analysis tool isn't possible.\nNeither is dedicating the only dev to full-time testing. Fortunately,\nsome tools are free (even open source) such as Valgrind or Clang-Tidy\nand some services are free to use, such as Coverity. We currently don't\nhave a high number of committers, but we have lots of dedicated testers\nand users.Big thanks to all of them, because without them nothing would\nhave been possible. So quality is possible. Maybe we can't reach the\n100% perfect quality state but we can reach a decent level."),(0,r.kt)("p",null,"The project took various actions in order to improve the quality and\nrobustness of PCSX2. Some actions started a long time ago, most of them\nare still on-going, some are still planned. You won't find any\nground-breaking methodology here. Nevertheless, I wanted to do a summary\nof what is going on."),(0,r.kt)("h1",{id:"continuous-integration"},"Continuous Integration"),(0,r.kt)("p",null,"The first step of QA is called\nContinuous Integration. The goal is to ensure correctness of the project\nat every commit done. That's easy to say but quite hard to do."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Most of you know about\nthe PCSX2 buildbot. It provides compiled snapshots regularly. It allows\ntesters and users to play with the latest features. It also gives them\nthe opportunity to report regressions much sooner in the development.\nTherefore, we can fix them better. Regressions are the highest priority\nbug reports for me.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The migration to Github\nallowed us to add additional bots to ensure compilation works fine with\nvarious compilers. PCSX2's buildbot is limited to a single version of\nthe Microsoft compiler. Appveyor & Travis allow us to test multiple\nversions of Visual Studio (VS2013 & VS2015) but also clang/gcc. We even\nhave a 64 bits compilation test validation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The buildbot is limited to\nWindows, therefore a daily PPA build was added too."))),(0,r.kt)("h2",{id:"compiler"},"Compiler"),(0,r.kt)("p",null,"The 2nd step of QA is compiler support. The compiler is the first tool\nof any developer. Of course, compilation errors are bad, but compilers\ncan also report constructs that are prone to errors. These are called\ncompiler warnings. Often there are false positives, the code is correct\nand behaves as expected but the compiler still reports it as dangerous.\nYou could say \"It's not a big deal.\", but when you have thousands of\nfalse positives, you don't see the bad warnings anymore. So the goal is\nto have 0 warnings for all compilers. Note that some warnings were\ndisabled because they report too many false positives. But they are a\nconscious exception and additional work has been done to re-enable them\nwhen possible."),(0,r.kt)("p",null,"*"," GCC warning counts are rather low (less than 20) but not 0 yet. And\nwe even enabled most of the extra warnings.\n","*"," Clang reports lots of warnings because I asked clang to report some\nold code that I marked as deprecated. Otherwise we'd be around 50. I'm\nsure we can do better here too."),(0,r.kt)("p",null,"Global status is rather good but not yet perfect. GCC used to have 500+\nwarnings with less warnings enabled. Clang used to be unable to compile\nthe code. The road was quite long but we started to see the light"),(0,r.kt)("h2",{id:"formallint-tool"},"Formal/Lint Tool"),(0,r.kt)("p",null,'Compilers are nice at reporting\nvarious problems but it isn\'t their main job. So dedicated tools were\ncreated with the single objective of finding all your bugs. In reality\nit is closer to "some bugs" but less bugs is always nice and good for\ne-reputation of a project. I decided to integrate those tools with the\nLinux build.sh script. This way, you can easily run them. If you want a\nreport, I will gladly send it to you.'),(0,r.kt)("h2",{id:"cppcheck"},"Cppcheck"),(0,r.kt)("p",null,"Cppcheck is an open-source lint tool to check code quality. For the\n1.2/1.4 release we tried to fix the big errors. So far it reports 838\nwarnings. The number is quite high but warnings are very minor\n(micro-optimization and style). It would require some analysis/fixes to\nimprove the situation. I guess some minor style warning could be\nfiltered."),(0,r.kt)("h2",{id:"coverity"},"Coverity"),(0,r.kt)("p",null,"Coverity is an expensive lint tool to ensure code robustness. It is very\nnice of Synopsys to allow open source projects to use it for free.\nCoverity is based on a compiler back-end so it tries harder than\nCppcheck to find issues. Coverity found a couple of nasty ones but also\nvarious false positives. We're currently around 70 issue reports. I'm\nnot sure we will be able to fix all the reports but we can target a goal\nof nearly 0 Coverity issues."),(0,r.kt)("h2",{id:"clang-tidy"},"Clang-tidy"),(0,r.kt)("p",null,"Clang-tidy is an open-source lint tool based on the Clang/LLVM compiler.\nIt is based on rule checks from the Clang / C++ core guidelines and C++\nISO certification. The tool reports a massive number of warnings,\ncurrently 49000+ !!!"),(0,r.kt)("p",null,"I can hear you yelling \"This is insane, PCSX2 code must suck so bad\".\nBut when you look at the report, the huge number comes from C/C++\nconstructs that are sane but not safe. There is a strong bias on\nrobustness/pure C++, rather than performance/C. For example, every time\nyou access an array, you must check the array boundary. For sure, this\nis robust but it is also slow. I'm not sure we want this kind of\nrobustness in performance critical code. That being said, all cold paths\n(i.e. code that doesn't impact performance) would be better with safer\ncode. Another recommendation is to use Boost classes. Boost is a nice\nbeast but it is a mammoth. The full include on my system is 155MB ! I\nthink we will wait until the interesting bits are included in the C++\nlibrary. A lot of warnings remain to be fixed but we are now far from\nthe 49K number."),(0,r.kt)("p",null,"For the record, here is the current summary report on the latest master.\nYou can google the rule name to find what the exact issue is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"cert (665)\ncert-dcl50-cpp => 85\ncert-err52-cpp => 3\ncert-err58-cpp => 360\ncert-err60-cpp => 148\ncert-err61-cpp => 69\n\nclang (496)\nclang-diagnostic-deprecated-declarations => 475\nclang-diagnostic-missing-braces => 2\nclang-diagnostic-shift-negative-value => 3\nclang-diagnostic-sign-compare => 4\nclang-diagnostic-unused-const-variable => 10\nclang-diagnostic-unused-variable => 2\n\ncppcoreguidelines (33701)\ncppcoreguidelines-pro-bounds-array-to-pointer-decay => 2883\ncppcoreguidelines-pro-bounds-constant-array-index => 7697\ncppcoreguidelines-pro-bounds-pointer-arithmetic => 3763\ncppcoreguidelines-pro-type-const-cast => 66\ncppcoreguidelines-pro-type-cstyle-cast => 3478\ncppcoreguidelines-pro-type-reinterpret-cast => 42\ncppcoreguidelines-pro-type-static-cast-downcast => 83\ncppcoreguidelines-pro-type-union-access => 12405\ncppcoreguidelines-pro-type-vararg => 3284\n\nmisc (905)\nmisc-macro-parentheses => 157\nmisc-throw-by-value-catch-by-reference => 18\nmisc-unused-alias-decls => 1\nmisc-unused-parameters => 729\n\nmodernize (2527)\nmodernize-loop-convert => 146\nmodernize-make-unique => 20\nmodernize-pass-by-value => 6\nmodernize-redundant-void-arg => 35\nmodernize-use-auto => 127\nmodernize-use-default => 107\nmodernize-use-nullptr => 1824\nmodernize-use-override => 262\n\nreadability (10996)\nreadability-braces-around-statements => 6739\nreadability-else-after-return => 124\nreadability-function-size => 1\nreadability-implicit-bool-cast => 3760\nreadability-inconsistent-declaration-parameter-name => 326\nreadability-named-parameter => 36\nreadability-simplify-boolean-expr => 10\n")),(0,r.kt)("p",null,"To conclude this section, lint tools are quite powerful. They can find\nbugs that will take days of tests. But they're also dull as they reports\ntons of false positives. Therefore it is required to filter the results.\nIt is clearly not feasible nor desirable to reach a 0 warnings target.\nHowever we can target a better and saner status."),(0,r.kt)("h1",{id:"dynamic-tools"},"Dynamic Tools"),(0,r.kt)("p",null,"Formal tools can't find all classes of bugs. Luckily for me, Linux comes\nwith 2 additional tools to ensure correct behavior at run time."),(0,r.kt)("h2",{id:"valgrind"},"Valgrind"),(0,r.kt)("p",null,"Valgrind is a virtual machine or a X86 CPU emulator. So yes, we are\nrunning an emulator inside an emulator"),(0,r.kt)("p",null,"The interesting stuff with virtual machines is that they can see all\nmemory accesses. It comes with a cost, it is damn slow. Another drawback\nis that Valgrind doesn't support all SIMD instruction such as AVX.\nRunning the tool allows you to detect memory leaks (ouch), memory\noverflows (ouch, ouch), code execution that depends on uninitialized\nvalues (ouch, ouch, ouch). Quite a nice tool; You even find bugs in 3rd\nparty libraries/drivers..."),(0,r.kt)("h2",{id:"address-sanitizer"},"Address sanitizer"),(0,r.kt)("p",null,"Valgrind is very powerful but too slow. The address sanitizer is a much\nfaster alternative but less powerful. The code will be instrumented\nduring the compilation. So every time you do a memory access, a small\ncheck is done. The main goal is to ensure the correctness of the memory\naccess, a big source of crashes and security flaws of all programs. It\ngreatly helps us to find wrong stack management on the recompiler."),(0,r.kt)("p",null,"Dynamic tools can greatly help to detect very bad stuff. Unlike formal\ntools that give you a status in 2 minutes, you need to actually run the\nprogram and play some games. So it is time consuming."),(0,r.kt)("h1",{id:"code-formatting"},"Code Formatting"),(0,r.kt)("p",null,"Last but not least, code formatting. The project is a mix of various\nplugins of various developers with various coding styles. It became even\nworse recently. We spend too much time in external contributions,\nreviewing the formatting rather than the real patch improvement."),(0,r.kt)("p",null,"As we said, desperate times call for desperate measures. So I decided\nthat we will automatically format the code with the help of the\nclang-format tool. The tool isn't perfect unlike us, Humans"),(0,r.kt)("p",null,"But it will give us a much nicer consistency."),(0,r.kt)("p",null,"Contributing will be easier as you don't need to learn the current\ncoding style of the current file. I hope to provide a git hook on Linux\nto automatically format the code before the commit. Reviewing will be\nfaster as the syntax will be automatically checked by the build bot.\nThis way we could concentrate on the meat. So far a couple of plugins\nwere converted to the new syntax. The remaining code will be converted\nstep by step in order to avoid conflicts with current Pull Requests."),(0,r.kt)("h1",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"To conclude this blog post, we have plenty of tools and methods to\nimprove the projects quality. We've worked on it for a long time and\nslowly it's getting better and better. In the end, QA is like ageing\nwine, it's a slow process that requires time."))}d.isMDXComponent=!0}}]);