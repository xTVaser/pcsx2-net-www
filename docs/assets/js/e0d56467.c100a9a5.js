"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[2626],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=d(n),u=o,m=p["".concat(l,".").concat(u)]||p[u]||c[u]||r;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1138:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const r={authors:["jake stine"],date:new Date("2009-10-07T00:00:00.000Z"),description:"It's the year 2009, and it's almost over at that; and as anyone reading this blog well knows, multithreaded applications are the here-and-now and future of desktop computing",draft:!1,tags:["devblog"],title:"Thread Synchronization"},i=void 0,s={permalink:"/blog/2009/thread-synchronization",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2009/thread-synchronization/index.mdx",source:"@site/blog/2009/thread-synchronization/index.mdx",title:"Thread Synchronization",description:"It's the year 2009, and it's almost over at that; and as anyone reading this blog well knows, multithreaded applications are the here-and-now and future of desktop computing",date:"2009-10-07T00:00:00.000Z",formattedDate:"October 7, 2009",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:3.27,hasTruncateMarker:!0,authors:[{name:"Jake Stine",key:"jake stine"}],frontMatter:{authors:["jake stine"],date:"2009-10-07T00:00:00.000Z",description:"It's the year 2009, and it's almost over at that; and as anyone reading this blog well knows, multithreaded applications are the here-and-now and future of desktop computing",draft:!1,tags:["devblog"],title:"Thread Synchronization"},prevItem:{title:"Thread Counting",permalink:"/blog/2009/thread-counting"},nextItem:{title:"Svn Comments Are Re Enabled",permalink:"/blog/2009/svn-comments-are-re-enabled"}},l={authorsImageUrls:[void 0]},d=[],h={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"It's the year 2009, and it's almost over at that; and as anyone reading\nthis blog well knows, multithreaded applications are the here-and-now\nand future of desktop computing. It's the only way we can take advantage\nof multicore CPUs. But multithreaded programming offers more than just\nimproved multicore performance. Using threaded programming is actually\nvery important to developing software that ",(0,o.kt)("strong",{parentName:"p"},"behaves nicely")," . By that\nI mean software that refreshes its window contents quickly, responds to\nyour mouse clicks, and lets you cancel stuff."),(0,o.kt)("p",null,'For that the best approach is usually threading, with the alternative\nbeing something called "Cooperative multitasking" where by a program is\nwritten such that it splits all tasks into neat little chunks. For\nexample, the two possible ways to implement loading an image (let\'s say\na png image):'),(0,o.kt)("p",null,"*"," Load the image one scanline at a time, and then after each scanline\nmanually check for keyboard, mouse, or other input, and refresh the\nscreen."),(0,o.kt)("p",null,"*",' Load the image using a thread, and let the usual "global" windows\nmessage handler dispatch keyboard, mouse, and refresh messages as\nusual.'),(0,o.kt)("p",null,"The second approach has several advantages. For one, it needs fewer\ntemporary heap allocations (which are typically slow and fragment\nmemory). It is more responsive: windows messages will be handled in\nparallel to the image loading, so you don't even need to \"wait\" until\nthe end of a scanline for user input to have its effect. It's also more\nscalable: while the first system is able to load one image at a time\nonly in co-operative fashion (extending it to support multiple is\npossible, but very difficult), the threaded approach can be scaled to\nload dozens of images at once with no additional complications."),(0,o.kt)("p",null,"The drawback is that thread synchronization and ",(0,o.kt)("em",{parentName:"p"},"especially")," structured\nerror handling across threads tends to be much more complicated than\nthat of the linear cooperative model. If you don't have errors to\nhandle, or don't really ",(0,o.kt)("em",{parentName:"p"},"care")," about handling errors, then threaded\ntasking isn't so bad."),(0,o.kt)("p",null,"Enter PCSX2, where everything ends up being damn complicated. Being a\nperfectionist, I figured I'd design the new GUI completely on the\nthreaded model, doing away with cooperative design almost completely.\nSuch a design should help avoid any deadlocking scenarios and allow the\nemu to recover from almost any error gracefully. Problem: The emulator\nhas a lot of inter-dependent parts and pieces that need to be\ninterlocked and synchronized, and all of them can throw out a variety of\nerrors -- which too I'd like to handle smartly; requesting extra user\ninput when appropriate (and not just throwing out annoying or vague\nmessage boxes)."),(0,o.kt)("p",null,"Interlocking dependencies can be a nightmare. For example, if you start\na thread that loads an image, and then ",(0,o.kt)("em",{parentName:"p"},"block")," on that thread until it\ncompletes, you're worse off than if you wrote yourself a cooperative\nimage loader because now the whole program stalls waiting for the thread\nto complete anyway. And like everything else, there are two ways to\nhandle this:"),(0,o.kt)("p",null,'(1) Use a "friendly" blocking mechanism that periodically polls the user\ninput and updates display. This is no better than cooperative\nsingle-thread designs though, as it has slow response times and doesn\'t\nscale well to multiple threads.'),(0,o.kt)("p",null,'(2) Build your entire GUI around "messages" and "callbacks" (sometimes\nalso called "signals"). This is the most flexible and user-friendly\noption but can add a lot of "framework" to any codebase.'),(0,o.kt)("p",null,"I tried to use the first approach initially, because I was in a hurry to\nget things working. But it's been problematic since day 1, so now I'm\nredoing most things to use the second method instead."),(0,o.kt)("p",null,"The second one is in fact the recommended design by Microsoft, and one\nthey've been using for almost everything in Windows ever since Win95.\nIt's one of the reasons the Win32 API feels \"heavy\" to a lot of\nprogrammers, but as it turns out, it's not without good reason."))}c.isMDXComponent=!0}}]);