"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[2493],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||a;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},79676:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(87462),r=(n(67294),n(3905));const a={authors:["zerofrog"],date:new Date("2006-07-24T00:00:00.000Z"),description:"It is very hard to emulate the floating-point calculations of the R5900 FPU and the Vector Units on an x86 CPU because the Playstation 2 does not follow the IEEE standard",draft:!1,tags:["devblog"],title:"Nightmare On Floating Point Street"},i=void 0,s={permalink:"/pcsx2-net-www/blog/2006/nightmare-on-floating-point-street",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2006/nightmare-on-floating-point-street/index.mdx",source:"@site/blog/2006/nightmare-on-floating-point-street/index.mdx",title:"Nightmare On Floating Point Street",description:"It is very hard to emulate the floating-point calculations of the R5900 FPU and the Vector Units on an x86 CPU because the Playstation 2 does not follow the IEEE standard",date:"2006-07-24T00:00:00.000Z",formattedDate:"July 24, 2006",tags:[{label:"devblog",permalink:"/pcsx2-net-www/blog/tags/devblog"}],readingTime:2.9,hasTruncateMarker:!0,authors:[{name:"zerofrog",key:"zerofrog"}],frontMatter:{authors:["zerofrog"],date:"2006-07-24T00:00:00.000Z",description:"It is very hard to emulate the floating-point calculations of the R5900 FPU and the Vector Units on an x86 CPU because the Playstation 2 does not follow the IEEE standard",draft:!1,tags:["devblog"],title:"Nightmare On Floating Point Street"},prevItem:{title:"Kosmos - Zerogs Just Evolved.",permalink:"/pcsx2-net-www/blog/2006/kosmos-zerogs-just-evolved"},nextItem:{title:"Introducing Devblogs",permalink:"/pcsx2-net-www/blog/2006/introducing-devblogs"}},l={authorsImageUrls:[void 0]},c=[],p={toc:c};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It is very hard to emulate the floating-point calculations of the R5900\nFPU and the Vector Units on an x86 CPU because the Playstation 2 does\nnot follow the IEEE standard. Multiplying two numbers on the FPU, VU,\nand an x86 processor can give you 3 different results all differing by a\ncouple of bits! Operations like square root and division are even more\nimprecise."),(0,r.kt)("p",null,"Originally, we thought that a couple of bits shouldn't matter, that game\ndevelopers would be crazy to rely on such precise calculation. Floating\npoints are mostly used for world transformations or interpolation\ncalculations, so no one would care if their Holy Sword of Armageddon was\n0.00001 meters off from the main player's hand. To put it shortly, we\nwere wrong and game developers are crazier than we thought. Games\nstarted breaking just by changing the floating point rounding mode!"),(0,r.kt)("p",null,"While rounding mode is a problem, the bigger nightmare is the\nfloating-point infinities. The IEEE standard states that when a number\noverflows (meaning that it is larger than 3.4028234663852886E+38), the\nresult will be infinity. Any number multiplied by infinity is infinity\n(even 0 ","*"," infinity = infinity). That sounds great until you figure out\nthat the VUs don't support infinities. Instead they clamp all large\nnumbers to the max floating point possible. This discrepancy breaks a\nlot of games!"),(0,r.kt)("p",null,"For example, let's say a game developer tries to normalize a zero vector\nby dividing by its length, which is 0. On the VU, the end result will be\n(0,0,0). On x86/IEEE, the result will be (infinity, infinity, infinity).\nNow if the game developer uses this vector to perturb some faces for\nartificial hair or some type of animation, all final positions on the\nPS2 will remain the same. All final positions on x86 will go to\ninfinity... and there goes the game's graphics, now figure out where the\nproblem occurred."),(0,r.kt)("p",null,"The simplest solution is to clamp the written vector of the current\ninstruction. This requires 2 SSE operations and is SLOW; and it doesn't\nwork sometimes. To top it off, you can never dismiss the fact that game\ndevelopers can be loading bad floating-point data to the VUs to begin\nwith! Some games zero out vectors by multiplying them with a zero, so\nthe VU doesn't care at all what kind of garbage the original vector's\ndata has, x86 does care."),(0,r.kt)("p",null,"These two problems make floating-point emulation very hard to do fast\nand accurate. The range of bugs are from screen flickering when a fade\noccurs, to disappearing characters, to spiky polygon syndrome (the most\ncommon problem and widely known as SPS)."),(0,r.kt)("p",null,"In the end Pcsx2 does all its floating-point operations with SSE since\nit is easier to cache the registers. Two different rounding modes are\nused for the FPU and VUs. Whenever a divide or rsqrt occur on the FPU,\noverflow is checked. Overflow is checked much more frequently with the\nVUs. The fact that VUs handle both integer and floating-point data in\nthe same SSE register makes the checking a little longer. In the future,\nPcsx2 will read the rounding mode and overflow settings from the patch\nfiles. This is so that all games can be accommodated with the\nbest/fastest settings."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Moral of the blog")," When comparing two floating point numbers ",(0,r.kt)("em",{parentName:"p"},"a")," and\n",(0,r.kt)("em",{parentName:"p"},"b")," , never use ",(0,r.kt)("em",{parentName:"p"},"a")," == ",(0,r.kt)("em",{parentName:"p"},"b")," . Instead use something along the lines of"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fabs(a-b) < epsilon\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"where ",(0,r.kt)("em",{parentName:"p"},"epsilon")," is some very small number.")))}h.isMDXComponent=!0}}]);