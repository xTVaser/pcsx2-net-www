"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[328],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var h=a.createContext({}),l=function(e){var t=a.useContext(h),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(h.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,h=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=l(n),u=r,g=d["".concat(h,".").concat(u)]||d[u]||p[u]||s;return n?a.createElement(g,o(o({ref:t},c),{},{components:n})):a.createElement(g,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=d;var i={};for(var h in t)hasOwnProperty.call(t,h)&&(i[h]=t[h]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85792:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const s={authors:["zerofrog"],date:new Date("2007-08-07T00:00:00.000Z"),description:"It was apparent early on the project that the GS plugin was going to be a big bottleneck during 3D scenes",draft:!1,tags:["devblog"],title:"Graphics Synthesizer Gpus And Dual Cores"},o=void 0,i={permalink:"/pcsx2-net-www/blog/2007/graphics-synthesizer-gpus-and-dual-cores",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2007/graphics-synthesizer-gpus-and-dual-cores/index.mdx",source:"@site/blog/2007/graphics-synthesizer-gpus-and-dual-cores/index.mdx",title:"Graphics Synthesizer Gpus And Dual Cores",description:"It was apparent early on the project that the GS plugin was going to be a big bottleneck during 3D scenes",date:"2007-08-07T00:00:00.000Z",formattedDate:"August 7, 2007",tags:[{label:"devblog",permalink:"/pcsx2-net-www/blog/tags/devblog"}],readingTime:4.46,hasTruncateMarker:!0,authors:[{name:"zerofrog",key:"zerofrog"}],frontMatter:{authors:["zerofrog"],date:"2007-08-07T00:00:00.000Z",description:"It was apparent early on the project that the GS plugin was going to be a big bottleneck during 3D scenes",draft:!1,tags:["devblog"],title:"Graphics Synthesizer Gpus And Dual Cores"},prevItem:{title:"Dynasty Warriors And Fullmetal Alchemist Videos On 0.9.4!",permalink:"/pcsx2-net-www/blog/2007/dynasty-warriors-and-fullmetal-alchemist-videos-on-0-9-4"},nextItem:{title:"2 New Plugins For Download",permalink:"/pcsx2-net-www/blog/2007/2-new-plugins-for-download"}},h={authorsImageUrls:[void 0]},l=[],c={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It was apparent early on the project that the GS plugin was going to be\na big bottleneck during 3D scenes. It isn't that the GS plugin itself\ndoes a lot of computation on the CPU, but the fact that it needs to\ncommunicate with the graphics card means that unnecessary stalls will\noccur in the graphics driver as the GPU and CPU are synchronized. During\nthese stalls, the CPU basically goes to lunch until the GPU is ready.\nGraphics drivers and libraries are aware of this and try as little as\npossible to communicate with the graphics card. They usually cache\nrender state changes, shader changes, and texture changes up until\nactual geometry is rendered. They also take advantage of FIFOs (first in\nfirst out buffers). The CPU just writes to the FIFO and the GPU just\nreads from it, this makes all the difference in terms of keeping the GPU\nactive while the CPU isn't and vise versa."),(0,r.kt)("p",null,"The biggest challenge when designing games and hardcore applications\nthat need to use the GPU to its full potential is to make sure that\ngraphics driver stalls are minimal ",(0,r.kt)("strong",{parentName:"p"},"at all costs")," . What kills games\nisn't sending geometry down the graphics pipeline, but it is when render\ntargets are switched, render targets are used as textures in the next\ndraw call, textures are locked, and when render targets are transferred\nfrom GPU memory to CPU memory (in the last case, the CPU not only goes\nto lunch, but has dinner also). GPU optimization talks usually appear in\nevery Game Developers Conference and there are many papers on them on\nthe net, so there is a lot more to the story than written here."),(0,r.kt)("p",null,"All this means is that single-threaded applications really need to\ndesign their GPU algorithms well to see fast frame rates. This\nunfortunately is not possible with Pcsx2 and the GS plugin. The GS\nplugin has to draw geometry in the same order as it was received. This\nkills almost all caching techniques used by modern games because the GS\nand PC GPUs have very different performance bottlenecks. In modern GPUs,\nit is advantageous to group as much geometry as possible in one draw\ncall. The GS doesn't suffer from such bottlenecks. The GS also has two\ndifferent contexts which makes things twice as difficult. ZeroGS can\nonly do a limited amount of work-arounds before compatibility starts\ndropping, so the only other option is to try to multithread the GS. Note\nthat using graphics libraries from multiple threads is not a trivial\ntask."),(0,r.kt)("p",null,"Fortunately, the GS plugin is very unique in its nature. 99% of the\ncommunication that happens between the GS plugin and the rest of the\nsystems components happens in the direction to the GS. The only times\nthe EE needs to synchronize with the GS is when it reads back the\nFINISH/SIGNAL registers and part of the 4Mb GS memory. Register\nreadbacks are used frequently, so this suggests that tight\nsynchronization will be needed with the GS. The GS memory readbacks\naren't as frequent; however, they require some special considerations\nwith Virtual Memory and DMAs. The rest of the 99% of communication that\ngoes to the GS happens with a GS FIFO."),(0,r.kt)("p",null,"When first started, Pcsx2 creates a GS thread and reserves special\nmemory for the GS FIFO. The GS plugin then creates the Direct3D\ndevice/GL context ",(0,r.kt)("strong",{parentName:"p"},"only for that thread")," . Then when the game runs,\nthe EE copes all its GS packets to the FIFO and then notifies the GS\nthread. The GS thread then checks if the FIFO has data, and then sends\nit to the GS plugin. This sounds easier than it actually is because very\ntight synchronization needs to happen to make sure no overwriting occurs\nin the FIFO. The FINISH/SIGNAL register synchronization actually doesn't\nhappen across the EE and GS thread boundaries. Instead the EE thread\npeeks at all the packets ahead of time and handles it in its own\nroutines."),(0,r.kt)("p",null,'What makes the "Dual Core" option special is the notifies part of the\nlast explanation. The GS thread can either sleep waiting for a\nnotification from EE, which can be done by WaitForSingleObject and\nSetEvent functions. Or it can continually check if the GS FIFO is empty\nwithout ever stopping. The latter option kills single cores but goes\nmuch faster on dual cores. The results of clicking on the MTGS and DC\noptions on dual cores are phenomenal. Usually frame rates go up or even\nsurpass 2x.'),(0,r.kt)("p",null,"Multithreading in games is going to be very big in the future. The times\nhave passed when there is one CPU that does everything and one GPU that\njust renders. The biggest problem is which game processing to divide\ninto which thread, and how these threads will communicate with each\nother. Many of these issues are still open and current game companies\nare struggling with the added complication of concurrent execution."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Moral of the blog")," - GPUs have become so powerful that people are\nstaring to do tasks like stereo vision and general purpose computation\nwith them. Learn how to use them. I recommend ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"ShaderX3: Advanced\nRendering with DirectX and OpenGL"))," by Wolfgang Engel and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"GPU Gems\n2: Programming Techniques for High-Performance Graphics and\nGeneral-Purpose Computation"))," by Matt Pharr, Randima Fernando, and the\n20+ researchers that contributed to it."))}p.isMDXComponent=!0}}]);