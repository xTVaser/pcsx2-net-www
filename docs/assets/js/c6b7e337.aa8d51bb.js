"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[4299],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),m=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=m(e.components);return o.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(n),h=r,d=p["".concat(s,".").concat(h)]||p[h]||c[h]||a;return n?o.createElement(d,i(i({ref:t},u),{},{components:n})):o.createElement(d,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var m=2;m<a;m++)i[m]=n[m];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},20259:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>m});var o=n(87462),r=(n(67294),n(3905));const a={authors:["jake stine"],date:new Date("2010-08-19T00:00:00.000Z"),description:"Yes, there is a way to simulate Microsoft's VirtualAlloc behavior on Linux",draft:!1,tags:["devblog"],title:"Virtualalloc On Linux"},i=void 0,l={permalink:"/blog/2010/virtualalloc-on-linux",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2010/virtualalloc-on-linux/index.mdx",source:"@site/blog/2010/virtualalloc-on-linux/index.mdx",title:"Virtualalloc On Linux",description:"Yes, there is a way to simulate Microsoft's VirtualAlloc behavior on Linux",date:"2010-08-19T00:00:00.000Z",formattedDate:"August 19, 2010",tags:[{label:"devblog",permalink:"/blog/tags/devblog"}],readingTime:3.13,hasTruncateMarker:!0,authors:[{name:"Jake Stine",key:"jake stine"}],frontMatter:{authors:["jake stine"],date:"2010-08-19T00:00:00.000Z",description:"Yes, there is a way to simulate Microsoft's VirtualAlloc behavior on Linux",draft:!1,tags:["devblog"],title:"Virtualalloc On Linux"},prevItem:{title:"Advanced Memory Management",permalink:"/blog/2010/advanced-memory-management"},nextItem:{title:"PCSX2 Plugins Update For Windows!",permalink:"/blog/2010/pcsx2-plugins-update-for-windows"}},s={authorsImageUrls:[void 0]},m=[],u={toc:m};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Yes, there is a way to simulate Microsoft's\n",(0,r.kt)("a",{parentName:"p",href:"http://msdn.microsoft.com/en-us/library/aa366887.aspx"},"VirtualAlloc"),"\nbehavior on Linux. Much searching of the internet did not reveal a\nsatisfactory answer; only hints that when combined with some applied\ntests of my own yielded the following result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// to RESERVE memory in Linux, use mmap with a private, anonymous, non-accessible mapping.\n// The following line reserves 1gb of ram starting at 0x10000000.\n\nvoid* result = mmap((void*)0x10000000, 0x40000000, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\n// to COMMIT memory in Linux, use mprotect on the range of memory you'd like to commit, and\n// grant the memory READ and/or WRITE access.\n// The following line commits 1mb of the buffer.  It will return -1 on out of memory errors.\n\nint result3 = mprotect((void*)0x10000000, 0x100000, PROT_READ | PROT_WRITE);\n")),(0,r.kt)("p",null,"When using ",(0,r.kt)("strong",{parentName:"p"},"mmap")," , you can create a simple uncommitted reservation of\nmemory simply by specifying PROT","_","NONE on any anonymous mapping (in the\nworld of mmap, anonymous means it has no associated file/pipe -- it's\njust a memory block). This is sufficient for reserving a large\ncontiguous address range from being fragmented up by the likes of\nmalloc. Granting the memory read and/or write privileges tells Linux to\n",(0,r.kt)("em",{parentName:"p"},"commit")," the memory (equivalent to VirtualAlloc with MEM","_","COMMIT). If\nthere is not enough system memory to complete the call, it returns -1."),(0,r.kt)("p",null,"Oddly enough, though, Linux makes it so that it isn't even necessary to\nbother with the above solution, via a strange little hacky technique\ncalled..."),(0,r.kt)("h1",{id:"over-committing-memory"},"Over-committing Memory"),(0,r.kt)("p",null,"This 'feature' is enabled by default in most modern Linux kernels\n(anything 2.6 or newer). Basically all this means is that Linux will let\nprograms ",(0,r.kt)("em",{parentName:"p"},"commit")," a lot more RAM than is actually available to the\noperating system! Instead of performing a \"strict contract\" on commit\nthat says \"oh yes we absolutely have this much ram available\", Linux\nlooks at the ram and looks at the request, and makes some arbitrary\njudgement call on if the program will actually use that much ram or not.\nIn other words, just because your call to malloc returned a valid\nnon-NULL pointer doesn't mean there's actually anywhere near that much\nmemory available to your app. It just means that Linux doesn't think\nyou're going to use that much."),(0,r.kt)("p",null,"Instead, as a program references its allocated memory, Linux commits the\nmemory on-demand. Most of the time, programs that malloc huge amounts of\nram only use a wee bit of it, so that's fine. By using ",(0,r.kt)("em",{parentName:"p"},"overcommitted"),'\nmemory management, Linux avoids the dreaded "Low on virtual memory!"\nerror that can sometimes plague Windows. This is actually highly ideal\nfor apps like PCSX2 and the Java virtual machine, for example. Kudos!'),(0,r.kt)("p",null,".. oh but things do get fun if apps over-step their bounds!"),(0,r.kt)("p",null,"Thanks to over-committing, Linux programs that run out of memory do not\nget error codes or NULL pointers. Instead they will typically be KILLED\nINSTANTLY by the kernel. They do not get out of memory errors, and they\ndon't even get SIGSEGV or anything else that can be handled or logged.\nThey just DIE -- because doing anything else would risk system\nstability. So in the long run, its still a good idea to use the\nReserve/Commit management strategy even on Linux (mmap / mprotect as\ndescribed above); because your app will be more likely to get proper\nout-of-memory errors instead of just causing itself (and possibly other\nprocesses on the system) to die suddenly and without warning or error."),(0,r.kt)("p",null,"Another positive for the the above mmap / mprotect example is that it\nwill also work ",(0,r.kt)("em",{parentName:"p"},"well"),' on Linux systems that have over-commit disabled,\nsince it basically does what over-commit does but without the hacky\n"programs die instantly without error" part if the system runs out of\nphysical memory.'))}c.isMDXComponent=!0}}]);