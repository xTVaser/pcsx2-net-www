"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[7667],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),h=r,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||a;return n?o.createElement(u,s(s({ref:t},c),{},{components:n})):o.createElement(u,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<a;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},50307:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var o=n(87462),r=(n(67294),n(3905));const a={authors:["zerofrog"],date:new Date("2006-07-30T00:00:00.000Z"),description:"The Playstation 2 uses co-processor 0 to implement virtual paging",draft:!1,tags:["devblog"],title:"Virtual Memory"},s=void 0,i={permalink:"/pcsx2-net-www/blog/2006/virtual-memory",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2006/virtual-memory/index.mdx",source:"@site/blog/2006/virtual-memory/index.mdx",title:"Virtual Memory",description:"The Playstation 2 uses co-processor 0 to implement virtual paging",date:"2006-07-30T00:00:00.000Z",formattedDate:"July 30, 2006",tags:[{label:"devblog",permalink:"/pcsx2-net-www/blog/tags/devblog"}],readingTime:3.845,hasTruncateMarker:!0,authors:[{name:"zerofrog",key:"zerofrog"}],frontMatter:{authors:["zerofrog"],date:"2006-07-30T00:00:00.000Z",description:"The Playstation 2 uses co-processor 0 to implement virtual paging",draft:!1,tags:["devblog"],title:"Virtual Memory"},prevItem:{title:"Kosmos Escapes - Zerogs 0.95!",permalink:"/pcsx2-net-www/blog/2006/kosmos-escapes-zerogs-0-95"},nextItem:{title:"Kosmos - Zerogs Just Evolved.",permalink:"/pcsx2-net-www/blog/2006/kosmos-zerogs-just-evolved"}},l={authorsImageUrls:[void 0]},p=[],c={toc:p};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,o.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The Playstation 2 uses co-processor 0 to implement virtual paging. Even\nwithout COP0, the Playstation 2 memory map is pretty complex and the\nmapping can change depending on which processor you use to read the\nmemory from. A simple version of how the default mapping looks from the\nEmotion Engine side is:"),(0,r.kt)("p",null,"The 32Mb of main memory occupying 0000","_","0000 - 01ff","_","ffff\nHardware registers occupying 1000","_","0000 - 1000","_","ffff\nVU/BIOS/SPU2 addresses in 1100","_","0000-1fff","_","ffff\nSpecial kernel modes etc in 8000","_","0000-bfff","_","ffff\nA scratch pad in some other address\n...And of course can't forget the hidden addresses (thanks SONY)"),(0,r.kt)("p",null,"To make matters worse, these mappings can change depending on the\nsetting of COP0. (Note that at the time of writing, Pcsx2 doesn't\nemulate even half of COP0 correctly.) The simplest and most\nstraightforward way to emulate this is to have another memory layer\nthrough a software Translation-Lookaside-Buffer (TLB). You pass it the\nPS2 address, and out comes the real physical address or some special\ncode signifying a hardware register, etc. The problem is that ",(0,r.kt)("strong",{parentName:"p"},"every\nread/write")," has to be preceded by a TLB lookup. Considering that\nreads/writes are as common as addition, that's a lot of wasted cycles."),(0,r.kt)("p",null,"Well, the OS also uses virtual memory. In fact, every process has its\nown special virtual memory driven by a real hardware TLB. If we could\nget away by mapping the 4Gb PS2 memory map onto the process's virtual\nmemory, we could eliminate the need for the software translation (Figure\n1). Looking at the virtual manipulation functions Windows XP offers,\nthere are two major problems with this:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(67669).Z,width:"580",height:"229"})),(0,r.kt)("p",null,"1 WindowsXP reserves more than half the address space for OS specific\nstuff. A good amount is also reserved for all of Pcsx2's working memory,\nexecutable code, and plugins (especially ZeroGS). It looks like we are\nleft with less than 1.5 Gb of address range to implement the 4Gb PS2\nmemory map. Note that this problem doesn't exist on 64bit operating\nsystems where the address range is practically... infinite (don't quote\nme on this 20 years down the road)."),(0,r.kt)("p",null,"2 Playstation 2 allows more than one virtual page to point to the same\nphysical page, Windows XP doesn't (I don't know about Linux). Assume\nthat PS2 address 0x1000 points to the same physical page as address\n0x0000, each page is 4Kb. Now a write occurs at 0x1000. The game can\nretrieve that same value just by reading from 0x0000. In Windows XP,\nthis has to be two different pages; so unless some clever\nsolution/technology is discovered, we could kiss our VM dreams\ngoodbye."),(0,r.kt)("p",null,"The first problem was solved somehow by introducing special address\ntransformations before a read/write occurs."),(0,r.kt)("p",null,"And thankfully a clever technology presented itself for the second\nproblem: ",(0,r.kt)("strong",{parentName:"p"},"Address Windowing Extensions")," . This lets Pcsx2 handle the\nactual physical page instead of a virtual page. We still can't map two\nvirtual pages to the same physical page; however, what we can do instead\nis switch the mapping of the physical page as many times as needed! To\nachieve this, Pcsx2 hacks into the root exception handler and intercepts\nevery exception the program generates. Whenever an illegal virtual page\nis accessed (ie, no physical page mapped to it), Pcsx2 gets a\nEXCEPTION","_","ACCESS","_","VIOLATION then it remaps the correct physical page to\nthat empty virtual page and returns. Although I haven't calculated\nprecisely, I'm pretty sure that switching physical pages around is\npretty expensive, computationally speaking. So all this works fine under\nthe assumption that game developers won't be crazy and access two\nvirtual pages mapping to the same physical page back-and-forth\nfrequently... ","[","pause","]","."),(0,r.kt)("p",null,"Alas, we were wrong... again (see floating-point article). It turns out\nthat there are uncached and cached address ranges; so it is optimal to\ndo such a bi-mapping trick: write in one virtual range and read from\nanother. Pcsx2 tries to detect such cases and work around, but there's\nno clean solution."),(0,r.kt)("p",null,"And I'm going to stop here before this becomes a book."),(0,r.kt)("p",null,"So the ultimate question is: why doesn't VM work on some computers with\n1Gb of RAM and the newest updates, while works on others? Turns out that\nreal-time monitoring applications like to take up some of the 1.5 Gb of\nleft over addresses on certain processes. (this might be OS specific\nprograms too). I have also observed that performance/debugging monitors\nlike NvPerfHud do similar tricks. There probably might be other reasons\nfor VM builds of Pcsx2 not working because virtual memory is a pretty\ncomplicated issue."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Moral of the blog")," Read an OS book. I recommend ",(0,r.kt)("a",{parentName:"p",href:"http://www.amazon.com/gp/product/0471694665/ref=sr_11_1/102-0719927-1309710?ie=UTF8"},(0,r.kt)("strong",{parentName:"a"},"Operating System\nConcepts")),"\n(the dinosaur book) by Abraham Silberschatz, Peter Baer Galvin, Greg\nGagne."))}m.isMDXComponent=!0},67669:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/vmem-82fe382b1d26de9e1695f5135e44e241.jpg"}}]);