"use strict";(self.webpackChunkpcsx_2_net=self.webpackChunkpcsx_2_net||[]).push([[1330],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),c=d(n),u=r,m=c["".concat(l,".").concat(u)]||c[u]||p[u]||o;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},62253:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const o={authors:["jake stine"],date:new Date("2010-10-07T00:00:00.000Z"),description:"As most people probably know, PCSX2 is primarily a dual-thread application",draft:!1,tags:["devblog"],title:"Benchmarking Multithreaded PCSX2"},i=void 0,s={permalink:"/pcsx2-net-www/blog/2010/benchmarking-multithreaded-pcsx2",editUrl:"https://github.com/PCSX2/pcsx2-net-www/tree/master/blog/2010/benchmarking-multithreaded-pcsx2/index.mdx",source:"@site/blog/2010/benchmarking-multithreaded-pcsx2/index.mdx",title:"Benchmarking Multithreaded PCSX2",description:"As most people probably know, PCSX2 is primarily a dual-thread application",date:"2010-10-07T00:00:00.000Z",formattedDate:"October 7, 2010",tags:[{label:"devblog",permalink:"/pcsx2-net-www/blog/tags/devblog"}],readingTime:3.345,hasTruncateMarker:!0,authors:[{name:"Jake Stine",key:"jake stine"}],frontMatter:{authors:["jake stine"],date:"2010-10-07T00:00:00.000Z",description:"As most people probably know, PCSX2 is primarily a dual-thread application",draft:!1,tags:["devblog"],title:"Benchmarking Multithreaded PCSX2"},prevItem:{title:"Configuration Guide For V0.9.7 And New Videos",permalink:"/pcsx2-net-www/blog/2010/configuration-guide-for-v0-9-7-and-new-videos"},nextItem:{title:"New PCSX2 0.9.7 Beta (R3878)!",permalink:"/pcsx2-net-www/blog/2010/new-pcsx2-0-9-7-beta"}},l={authorsImageUrls:[void 0]},d=[],h={toc:d};function p(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As most people probably know, PCSX2 is primarily a dual-thread\napplication. The two main threads are described as such:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"EE/Core thread emulates the PS2's EmotionEngine (including VIF, SIF,\nGIF, and VUs) and the IOP (including SPU2, CDVD, and PAD)"),(0,r.kt)("li",{parentName:"ul"},"GS thread emulates the PS2's Graphic Synthesizer (includes texture\nswizzling, texture filtering, upscaling, and frame rendering)")),(0,r.kt)("p",null,"Each thread relies on the other thread in some way -- the GS thread\ncannot swizzle texture data until the EE thread has uploaded said data,\nfor example. Meanwhile, the EE thread cannot upload texture data to the\nGS thread if the GS thread is currently bogged down rendering last\nweek's frame to video. During these periods, either thread will ",(0,r.kt)("em",{parentName:"p"},"sleep"),"\n, only to be woken up once the other thread has caught up in its\nworkload."),(0,r.kt)("p",null,"In theory the act of sleeping the EE/GS threads should make benchmarking\nthe CPU load registered by each thread pretty easy: all modern operating\nsystems have built-in APIs for reading the busy/idle time of any thread\non the system -- this is the same API used by your tried and true\ntask/process manager, for example:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(68110).Z,width:"408",height:"261"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"(Air shows off his personal favorite,\n",(0,r.kt)("a",{parentName:"em",href:"http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx"},"ProcessExplorer"),"\n, part of the ",(0,r.kt)("a",{parentName:"em",href:"http://technet.microsoft.com/en-us/sysinternals/default.aspx"},"SysInternals\nSuite"),"\n)")),(0,r.kt)("p",null,"This readout is simple, efficient, and seemingly reliable. It also\navoids a lot of the annoying pitfalls one runs into trying to use common\nalternatives such as\n",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Time_Stamp_Counter"},"rdtsc")," and\n",(0,r.kt)("a",{parentName:"p",href:"http://msdn.microsoft.com/en-us/library/ms644904.aspx"},"QueryPerformanceCounter"),"\n."),(0,r.kt)("p",null,"... and this is precisely the method I decided to use for PCSX2\n0.9.7.r3113 (and still in use as of r3878). Simple theory really: if the\nGS thread is sleeping a lot (low load) then the game is bottlenecked by\nEE/Core thread activity. If the EE thread is sleeping a lot and the GS\nthread reports 90+%, then the GS thread is the bottleneck (a problem\noften correctable through using lower internal resolutions, for\nexample)."),(0,r.kt)("p",null,"But as I've recently found out, it doesn't work as expected. -","_","-"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"It's filled with... threads!")),(0,r.kt)("p",null,"The immediate problem faced by this simple method of load detection is\nthat the latest wave of Windows Vista/7 GPU drivers themselves ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"are\nmultithreaded"))," . It should have come as little surprise that one of\nthe primary goals of the new DWM/Aero/DX11 systems implemented into\nVista/7 is scalable parallel processing that takes better advantage of\nmodern multi-core CPUs. Why this causes the OS built-in thread load\ndetection to fail might be less obvious; I'll explain with an example:"),(0,r.kt)("p",null,"When the GPU driver receives a directive to render the current scene\n(aka 'Present' in DirectX lingo), it sends the job to a thread dedicated\nto the task. That thread has a ",(0,r.kt)("em",{parentName:"p"},"Present Queue")," , typically 1 or 2 frames\ndeep, that automatically handles triple buffered vsync'd page updates.\nIf the queue is full when the PCSX2 GS thread issues its next Present\nrequest, the ",(0,r.kt)("strong",{parentName:"p"},"GPU driver will put the GS thread to sleep")," until a slot\nin the Present Queue becomes available. End result: The GS thread\nreports idle time to the operating system (and to PCSX2's GS window),\nbut the GPU is still quite overloaded and bottlenecked via work supplied\nto it by a different thread altogether."),(0,r.kt)("p",null,"In essence, it is nearly the same sort of inter-thread dependence that\nthe EE/Core and GS threads have between each other, only now the EE/Core\nthread's dependency chain extends to include GS ",(0,r.kt)("em",{parentName:"p"},"and")," GPU driver threads\n(of which there could be one or many)."),(0,r.kt)("p",null,"The solution to this problem is to use a more traditional method of\nmanual load checking: timing various sections of code executed in-thread\nvia either the aforementioned rdtsc (timestamp) or\nQueryPerformanceCounter, read at key points in the GS thread's\nexecution/program flow. This wasn't such a great idea a few years ago,\ndue to K8/Athlon and P4 generation CPUs lacking a stable internal clock\ncounter. Fortunately, all modern CPUs have a consistent counter suitable\nfor benchmarking, so the pitfalls that have been long associated with\nusing Intel/AMD timestamps are finally obsolete enough to not be a\nconcern for us here."))}p.isMDXComponent=!0},68110:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/sysinternal-0826bdc6a94aad312272c2cbb85205d8.webp"}}]);